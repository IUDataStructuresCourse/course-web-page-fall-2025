/* ~/~ begin <<deduce-programming.en#DeduceProgramming.pf>>[init] */
/* ~/~ begin <<deduce-programming.en#importUInt>>[init] */
import UInt
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#Fruit>>[init] */
union Fruit {
  apple
  orange
  banana
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#apple>>[init] */
define f1 : Fruit = apple
define f2 : Fruit = banana
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#UIntList>>[init] */
union UIntList {
  Empty
  Node(UInt, UIntList)
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#UIntListL>>[init] */
define L = Node(7, Node(4, Node(5, Empty)))
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#len>>[init] */
recursive len(UIntList) -> UInt {
  len(Empty) = 0
  len(Node(n, next)) = 1 + len(next)
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#lenL3>>[init] */
assert len(L) = 3
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#printFive>>[init] */
print 5
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#area>>[init] */
define area = fun h : UInt, w : UInt { h * w }
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#area12>>[init] */
assert area(3, 4) = 12
/* ~/~ end */

/* ~/~ begin <<deduce-programming.en#Fruit2>>[init] */
union Fruit2 {
  apple
  orange
  banana(bool)
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#banana>>[init] */
define f3 : Fruit2 = banana(false)
define f4 : Fruit2 = banana(true)
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#switchFruit2>>[init] */
define r4 : bool = 
    switch f4 {
      case apple { false }
      case orange { false }
      case banana(r) { r }
    }
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#assertR4>>[init] */
assert r4
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#List>>[init] */
union List<T> {
  empty
  node(T, List<T>)
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#List123>>[init] */
define list_123 : List<UInt> = node(1, node(2, node(3, empty)))
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#List456>>[init] */
define list_456 = [4,5,6]
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#List123456>>[init] */
define list_of_list = [list_123, list_456]
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#length>>[init] */
recursive length<E>(List<E>) -> UInt {
  length(empty) = 0
  length(node(n, next)) = 1 + length(next)
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#assertIfTrue>>[init] */
print if length([1,2,3]) = 3 then 42 else 0
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#search>>[init] */
recursive search(List<UInt>, UInt) -> UInt {
  search(empty, y) = 0
  search(node(x, xs), y) =
    if x = y then 0
    else 1 + search(xs, y)
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#searchExamples>>[init] */
assert search(list_123, 1) = 0
assert search(list_123, 2) = 1
assert search(list_123, 3) = 2
assert search(list_123, 4) = 3
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#Pair>>[init] */
union Pair<T,U> {
  pair(T,U)
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#firstSecond>>[init] */
fun first<T,U>(p : Pair<T,U>)  {
  switch p {
    case pair(x,y) { x }
  }
}

fun second<T,U>(p : Pair<T,U>) {
  switch p {
    case pair(x,y) { y }
  }
}
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#firstPair>>[init] */
assert first(pair(3,7)) = 3
assert second(pair(3,7)) = 7
/* ~/~ end */
/* ~/~ begin <<deduce-programming.en#swap>>[init] */
fun swap<T, U>(p:Pair<T,U>) {
  pair(second(p), first(p))
}

assert first(swap(pair(1,2))) = 2
assert first(swap(pair(true,false))) = false
/* ~/~ end */
/* ~/~ end */